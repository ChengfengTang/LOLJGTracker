<!-- to do 

!! Kills/movements/and all other information are prined and shown on a minute basis, rather they should be shown whenever there is an update

1. tower/dragons/barons?
2. reload game upon end (or just add a slide bar that controls time)
3. Champion info shown on the right side? (kda, cs, lvl, items)
-->
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>LoL Jungle Tracker - Replay</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
  body {
    display: flex;
    margin: 0;
    background: #111;
    color: white;
    height: 100vh;
    overflow: hidden;
  }

  #log {
    width: 300px;
    max-height: 100vh;
    padding: 10px;
    overflow-y: auto;
    font-family: monospace;
    background: #1a1a1a;
    border-right: 2px solid #333;
  }

  canvas {
    display: block;
    background: #000;
  }
</style>
</head>
<body>
  <div id="log"><b>ðŸ“œ Event Log</b><br /></div>

<script>
let champIconMap = {};  // Stores loaded champion images
let championNames = new Set();  // To preload icons
let champMap = {};
let junglerData = [];
let events = [];
let mapImg;
let scaleFactor;
const mapSize = 1024;
const canvasSize = 910;
let currentGameTime = 0;
let lastTickTime = 0;
const tickInterval = 1000;
const gameTimePerTick = 10;
const matchId = new URLSearchParams(window.location.search).get("matchId");
const displayedEvents = new Set();

function msToMinSec(ms) {
  const m = Math.floor(ms / 60000);
  const s = Math.floor((ms % 60000) / 1000);
  return `${m}:${s.toString().padStart(2, '0')}`;
}

function label(champ) {
  return champ.team === "Blue" ? `ðŸ”µ ${champ.name}` : `ðŸ”´ ${champ.name}`;
}

function timeToSeconds(timeStr) {
  const [minutes, seconds] = timeStr.split(':').map(Number);
  return minutes * 60 + seconds;
}

function drawDiamond(x, y, size) {
  beginShape();
  vertex(x, y - size);
  vertex(x + size, y);
  vertex(x, y + size);
  vertex(x - size, y);
  endShape(CLOSE);
}

function preload() {
  mapImg = loadImage('/static/SRMap.png');
}

async function fetchData() 
{

  try {
    const res = await fetch(`/api/match/${matchId}`);
    const { metadata, timeline } = await res.json();

    champMap = {};
    for (const p of metadata.info.participants) 
    {
      const name = p.championName;
      champMap[p.participantId] = {
        name,
        team: p.teamId === 100 ? "Blue" : "Red"
      };
      championNames.add(name);
    }
    for (let name of championNames) 
    {
    let patchVersion = "15.11.1"; // Fallback value as of 6/1/2025, needs update 
    async function fetchLatestPatchVersion() 
    {
      try 
      {
        const res = await fetch("https://ddragon.leagueoflegends.com/api/versions.json");
        const versions = await res.json();
        patchVersion = versions[0];
      } 
      catch (e) 
      {
        console.warn("Failed to fetch patch version. Using fallback:", patchVersion);
      }
    }
    champIconMap[name] = await new Promise((resolve) => 
    {
      loadImage(`https://ddragon.leagueoflegends.com/cdn/${patchVersion}/img/champion/${name}.png`, resolve);
    });
    }


    for (const frame of timeline.info.frames) {
      const ts = msToMinSec(frame.timestamp);
      const timeSec = frame.timestamp / 1000;
      for (const [pid, pf] of Object.entries(frame.participantFrames)) {
        if (!pf.position) continue;
        junglerData.push({
          id: parseInt(pid),
          time: ts,
          timeSeconds: timeSec,
          x: pf.position.x,
          y: pf.position.y,
          level: pf.level || 1,
          cs: (pf.minionsKilled || 0) + (pf.jungleMinionsKilled || 0),
          gold: pf.currentGold || 0
        });
      }
    }

    for (const frame of timeline.info.frames) {
      const t = msToMinSec(frame.timestamp);
      const timeSec = frame.timestamp / 1000;
      for (const event of frame.events || []) {
        const type = event.type;
        if (type === "CHAMPION_KILL") {
          const killer = champMap[event.killerId];
          const victim = champMap[event.victimId];
          if (!killer || !victim) continue;

          events.push({ time: t, timeSeconds: timeSec, event: `ðŸ’€ ${label(killer)} killed ${label(victim)} at (${event.position?.x}, ${event.position?.y})` });

          for (const a of (event.assistingParticipantIds || [])) {
            const assist = champMap[a];
            if (assist) {
              events.push({ time: t, timeSeconds: timeSec, event: `ðŸ¤ ${label(assist)} assisted the kill` });
            }
          }
        } else if (type === "ELITE_MONSTER_KILL") {
          const killer = champMap[event.killerId];
          const monster = event.monsterType;
          if (killer) {
            events.push({ time: t, timeSeconds: timeSec, event: `ðŸ‘¾ ${label(killer)} killed ${monster} at (${event.position?.x}, ${event.position?.y})` });
          }
        } else if (type === "LEVEL_UP") {
          const champ = champMap[event.participantId];
          const lvl = event.level;
          if (champ && [6, 11, 16].includes(lvl)) {
            events.push({ time: t, timeSeconds: timeSec, event: `ðŸ†™ ${label(champ)} leveled up to ${lvl}` });
          }
        }
      }
    }

    console.log("âœ… Data loaded:", junglerData.length, "points,", events.length, "events");

  } catch (err) {
    console.error("âŒ Failed to load match data:", err);
  }
}

async function setup() {
  createCanvas(canvasSize, canvasSize).parent(document.body);
  scaleFactor = canvasSize / mapSize;
  textSize(10);
  textAlign(LEFT);
  lastTickTime = millis();
  await fetchData();
}

function draw() {
  background(0);

  if (mapImg) image(mapImg, 0, 0, canvasSize, canvasSize);
  else {
    fill(50);
    rect(0, 0, canvasSize, canvasSize);
    fill(255);
    text("Err loading map...", 10, 20);
    return;
  }

  const elapsedTime = millis();
  if (elapsedTime - lastTickTime >= tickInterval) {
    currentGameTime += gameTimePerTick;
    lastTickTime = elapsedTime;
  }

  const grouped = {};
  for (const point of junglerData) {
    if (!grouped[point.id]) grouped[point.id] = [];
    grouped[point.id].push(point);
  }

  for (const [pid, points] of Object.entries(grouped)) {
    let curr = null;
    for (let i = 0; i < points.length; i++) {
      if (points[i].timeSeconds > currentGameTime) break;
      curr = points[i];
    }
    if (curr) {
      const x = (curr.x / 15000) * mapSize * scaleFactor;
      const y = ((15000 - curr.y) / 15000) * mapSize * scaleFactor;
      imageMode(CENTER);
      let champ = champMap[curr.id];
      let icon = champ && champIconMap[champ.name];
      if (icon) {
        // Border color based on team
        strokeWeight(3);
        stroke(champ.team === "Blue" ? color(0, 128, 255) : color(255, 0, 0));
        rect(x - 16, y - 16, 32, 32);
        noStroke();
        image(icon, x, y, 32, 32);
      }
      imageMode(CORNER);
    }
  }

  for (const e of events) {
    const eventTime = e.timeSeconds;
    if (
      currentGameTime >= eventTime &&
      !displayedEvents.has(e)
    ) {
      displayedEvents.add(e);
      const div = document.createElement("div");
      div.textContent = `${e.time} - ${e.event}`;
      document.getElementById("log").appendChild(div);
    }

    // Draw map icon for kill/monster events for 30 seconds
    if (
      currentGameTime >= eventTime &&
      currentGameTime <= eventTime + 30 &&
      /\(\d+, \d+\)/.test(e.event)
    ) {
      const match = e.event.match(/\((\d+), (\d+)\)/);
      if (match) {
        const [_, xRaw, yRaw] = match.map(Number);
        const x = (xRaw / 15000) * mapSize * scaleFactor;
        const y = ((15000 - yRaw) / 15000) * mapSize * scaleFactor;
        fill(255);
        textSize(18);
        text("\uD83D\uDC80", x - 8, y + 8); // ðŸ’€ skull emoji
      }
    }
  }

  const m = Math.floor(currentGameTime / 60);
  const s = Math.floor(currentGameTime % 60).toString().padStart(2, "0");
  fill(255);
  text(`\u23F1\uFE0F ${m}:${s}`, 10, 20);
}

</script>
</body>
</html>
